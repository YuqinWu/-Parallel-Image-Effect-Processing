/* proj2 guideline */
/* MPCS52060, Spring 2019 */

/* === Evaluation === */
/* Completeness (& Correctness) 	  */ 
/*       Sequential version (including convolution) 20/20 */ 
/*       Parallel version                           28/31 */ 
/*       Performance Analysis Writeup	            34/37 */        
/* Design & Style             	                    9/12 */

/* _TOTAL-SCORE_    91/100 */

/* graded by Collin Olander */

Nice job. Well commented code and handled images properly.

Design and Style: -3 -> too much work being done in main(). That should be used for parsing flags and calling the necessary functions.
    ie) the parallel and sequential work should be seperate functions that are called as needed.

Parallel Version (also Design & Style) -3 -> Having the queue struct implemented in editor.go. Would've been better/cleaner to have a queue package where you implemented this
    struct and could define functions like NewQueue() instead of having to initialize it and deal with the leg work in your main program.

Performance Analysis Writeup -3 -> #2 Describe the granularity in your implementation. Are you using a coarse-grain or fine-graingranularity? Explain
    You said "I think my implementation is a fine-grain granularity because each time one effect is done, allthreads have to wait for the last one to finish." 
    but granularity refers to the size/scope of the tasks, or the ratio of computation to communication. All threads would have to wait for all other threads to
    complete their effects on the image, regardless of it were fine or coarse grained. 

    Not sure what you meant by "This can be regarded as a type of synchronization and it is a little bit frequently"
